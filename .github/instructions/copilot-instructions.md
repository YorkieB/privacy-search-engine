
# Project Overview
This project is a **privacy-focused homepage search engine** that integrates with Brave Search. It features a custom frontend for entering queries and displaying results, a backend service that queries the Brave Search API (and potentially other sources), and a search logic module for processing and caching results. The goal is to provide fast, unbiased search results with **no user tracking**, aligning with Brave’s privacy principles.

# Technology Stack & Preferences
- **Frontend**: Modern JavaScript (ES6+) with a framework like **React** (using JSX) for building a dynamic UI. Utilise HTML5, CSS3 (or SCSS), and possibly a UI toolkit (e.g., Tailwind CSS or Bootstrap) for responsive design. Ensure all frontend code is lightweight and respects user privacy (no unnecessary external calls).
- **Backend**: **Node.js** with **Express** (or a minimalist framework like Fastify) for the API server. Use `node-fetch` or `axios` for HTTP requests to Brave’s API. Follow asynchronous best practices (async/await) and non-blocking design.
- **Search Integration**: Use the **Brave Search API** for web search results (and other Brave endpoints for images, news, etc., if needed). If implementing any local search or indexing, consider lightweight libraries like **Lunr.js** (for in-memory search) or an embedded search engine. However, prefer using Brave’s index to avoid storing large data locally.
- **Data & State**: No database is required for search results (results fetched on the fly or cached in memory). If user preferences or history are implemented, use localStorage on the client (for privacy) or a small backend store only with user consent.
- **Testing**: Use **Jest** (for both frontend and backend JavaScript) to write unit and integration tests. Aim for high coverage on search logic and any critical utility functions. Use a headless browser or React Testing Library for frontend component testing, and supertest for API endpoint testing.

# Coding Standards
- **General Style**: Follow consistent coding conventions (e.g., Airbnb JavaScript style guide). Use 2 spaces for indentation. Prefer `const` for constants, `let` for mutable variables, and avoid using `var`. End all statements with semicolons. Use trailing commas in multi-line objects/arrays.
- **Syntax**: Use ES6+ features (arrow functions, template literals, destructuring, spread/rest). For React components, prefer functional components with hooks over class components.
- **Naming Conventions**: 
  - Files and directories: use **kebab-case** (e.g., `search-results.js`, `search-controller.js`).
  - Variables and functions: use clear **camelCase** names (`searchQuery`, `fetchResults`), with verbs for functions (`handleSubmit`).
  - Classes and React components: **PascalCase** (`SearchBar`, `ResultItem`).
  - Constants: `UPPER_SNAKE_CASE` for constants (e.g., `MAX_RESULTS`).
- **Comments**: Write self-documenting code where possible. Use comments to explain non-obvious logic or complex sections, especially in the search algorithm. For any public API endpoints or complex functions, include JSDoc or /** documentation comments **/ explaining its purpose and usage.
- **File Organisation**: Keep files focused. For example, one React component per file; in backend, separate route definitions, controllers, and utilities into different files. This makes it easier to maintain and ensures Copilot suggestions stay relevant to the context.

# Security & Privacy Practices
- **API Keys**: Do not hardcode the Brave API key or any credentials. They should be loaded from environment variables (e.g., `BRAVE_API_KEY`) via a config file or `dotenv`. Never commit secrets to the repository.
- **User Data**: Do not log or store personal user queries or identifying information on the server. This search engine should not build user profiles. If caching search results, use query hashes or ephemeral in-memory caching without storing user identity.
- **Requests to Brave**: Use HTTPS for all calls to Brave’s API. Include only necessary data (e.g., query, API key, options) in requests. **Do not send** any user-identifiable information to Brave beyond the query itself. Respect Brave’s terms of service (e.g., rate limits, attribution requirements).
- **Output Handling**: Be careful with displaying search results. Escape any HTML in results snippets to avoid XSS, unless the result component is specifically sanitising it. The frontend should render result titles and descriptions safely (e.g., using React’s automatic escaping or DOM methods that prevent injection).
- **Dependencies**: Use trusted libraries with active maintenance. Keep them updated to patch vulnerabilities. Avoid very large or tracking-heavy libraries; choose privacy-conscious alternatives (for example, avoid Google Analytics scripts or any tracker).
- **Content Security Policy**: When building the frontend, ensure a strong Content Security Policy (CSP) if possible (restricting script sources, etc.) to mitigate XSS. Do not include external scripts or trackers. If using any third-party assets (fonts, icons), host them locally to avoid unintended data exposure.

# Project Behaviour Expectations
- **Performance**: Aim for fast load times and low latency in search results. Utilise caching of results where appropriate to speed up repeat queries. Keep JavaScript bundle sizes small on the frontend for quick initial load.
- **Accessibility**: The search interface should be fully accessible. Ensure proper ARIA labels (e.g., label the search input, mark up results list with appropriate roles), keyboard navigation (tab through links, press Enter to search), and high-contrast, legible text. Copilot should suggest code that upholds these principles.
- **Responsiveness**: The UI should work on various screen sizes (desktop, mobile). Use responsive design (CSS flex, grid, media queries) for layout. Copilot suggestions for CSS/HTML should be checked for mobile-friendliness.
- **Consistency**: Follow the DRY (Don't Repeat Yourself) principle. If similar logic is needed in multiple places, refactor into a shared function or component. This applies to formatting search results, error handling, etc.
- **Error Handling**: Handle errors gracefully on both frontend and backend. If the Brave API call fails, the backend should catch the error and return a clean error response (with a user-friendly message, not a stack trace). The frontend should detect an error response and display an informative message to the user (“Unable to fetch results, please try again.”). Copilot should avoid suggesting raw errors be sent to users.
- **Git Practices**: Write clear commit messages in the imperative mood (“Add X”, “Fix Y”). Keep diffs small and focused. Do not commit build outputs or node_modules. Include a `.gitignore` for node_modules, .env, and build artifacts.
- **Copilot Usage**: Use these instructions and the folder-specific ones below to guide GitHub Copilot. If Copilot suggestions ever contradict this document (for example, using a style that’s disallowed or a library that’s off-limits), those suggestions should be modified or ignored. The aim is for Copilot to generate code that meets our standards out-of-the-box, requiring only minimal tweaks.

## Safety and Change Control
- **Stay Within Scope**: Copilot should only modify or create files relevant to the current task or prompt. It **must not** refactor or “optimise” unrelated code on its own. For example, if working on the frontend, Copilot should not suddenly change backend logic (and vice versa) unless explicitly asked.
- **Non-Destructive Edits**: Avoid making destructive changes (such as deleting code or files) without explicit instruction. If a piece of code seems unused or redundant, Copilot should flag it with a comment (e.g., `// TODO: consider removing this if not needed`) rather than just removing it.
- **Flag Uncertain Suggestions**: If Copilot is unsure about a change, it should make a note in the code instead of a confident edit. For instance, it can insert a comment like `// TODO: Confirm if this change is appropriate` or `// Uncertain: please review this logic`. This gives a clear signal to review that part manually.
- **Do Not Reformat Unless Asked**: Copilot should not reformat entire files or sections just to match a style. Formatting is handled by our linters/formatter. Unnecessary reformatting can cause merge conflicts and obscure the real changes. Only format code that Copilot itself is writing or that is immediately around the changes it must make.
- **Maintain Behaviour**: Unless the goal of the task is to change functionality, Copilot must ensure that any suggestions do not alter the existing behaviour of the application. If it’s making an improvement (like refactoring for clarity), the external behaviour (output, side-effects) should remain the same.
- **Ask for Confirmation on Major Changes**: For any significant architectural change or anything that affects many files, Copilot (especially in Agent mode) should defer to human confirmation. It can outline a plan or propose the change via comments or in a pull request description, but not apply it without review.
- **Follow These Guidelines**: Copilot’s suggestions are expected to comply with all sections of this instructions file. This Safety and Change Control section is especially important: any suggestion that might violate these rules should be reconsidered by Copilot (or not offered at all). Ultimately, when in doubt, Copilot should err on the side of caution and seek clarification (via comments or by not making the leap).
